<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>myBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-20T16:00:00.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>luluji</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟机环境配置指南</title>
    <link href="http://example.com/2024/04/01/tools/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/04/01/tools/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE/</id>
    <published>2024-03-31T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>详细介绍虚拟机环境的配置方法，包括静态IP设置、防火墙管理、SELinux配置等内容。</p><span id="more"></span><h2 id="配置静态ip"><a href="#配置静态ip" class="headerlink" title="配置静态ip"></a>配置静态ip</h2><h4 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h4><p><a href="https://blog.csdn.net/Un1qu3/article/details/126155766">https://blog.csdn.net/Un1qu3/article/details/126155766</a><br><a href="https://blog.csdn.net/Conquer_l/article/details/124989551">https://blog.csdn.net/Conquer_l/article/details/124989551</a><br><a href="https://blog.csdn.net/lk142500/article/details/88386651">https://blog.csdn.net/lk142500/article/details/88386651</a><br><img src="/2146089-20200911223717884-1559586693.png" alt="alt text"><br><a href="https://www.cnblogs.com/yansunda/p/13654632.html">https://www.cnblogs.com/yansunda/p/13654632.html</a></p><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth33<br>sudo systemctl restart NetworkManager</p><h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h4><p><a href="https://blog.csdn.net/weixin_58305495/article/details/130554393">https://blog.csdn.net/weixin_58305495/article/details/130554393</a></p><p>1:查看防火状态<br>systemctl status firewalld<br>service  iptables status<br>2:暂时关闭防火墙<br>systemctl stop firewalld<br>service  iptables stop<br>3:永久关闭防火墙<br>systemctl disable firewalld<br>chkconfig iptables off<br>4:重启防火墙<br>systemctl enable firewalld<br>service iptables restart<br>5:永久关闭后重启<br>chkconfig iptables on  </p><p>关闭selinux<br>暂时：<br>setenforce 0<br>永久：<br>输入命令 <code>vi /etc/selinux/config</code>。<br>在打开的文件中，找到 <code>SELINUX=</code> 这一行，将其从 <code>enforcing</code> 或 <code>permissive</code> 修改为 <code>disabled</code>。</p><p>arp -a<br>展示运行过的ping</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;详细介绍虚拟机环境的配置方法，包括静态IP设置、防火墙管理、SELinux配置等内容。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    <category term="虚拟化" scheme="http://example.com/categories/tools/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="系统管理" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    
    <category term="虚拟机" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="网络配置" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>一生一芯相关资料</title>
    <link href="http://example.com/2024/01/21/ysyx/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/"/>
    <id>http://example.com/2024/01/21/ysyx/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</id>
    <published>2024-01-20T16:00:00.000Z</published>
    <updated>2025-01-21T07:08:38.211Z</updated>
    
    <content type="html"><![CDATA[<p>准备寒假有空研究一下</p><span id="more"></span><h2 id="报名参与"><a href="#报名参与" class="headerlink" title="报名参与"></a>报名参与</h2><p><a href="https://ysyx.oscc.cc/signup/">https://ysyx.oscc.cc/signup/</a><br>填写问卷-&gt;进入课程群-&gt;预学习-&gt;申请答辩-&gt;获得专属学号-&gt;.etc</p><h2 id="深圳理工训练营"><a href="#深圳理工训练营" class="headerlink" title="深圳理工训练营"></a>深圳理工训练营</h2><p><a href="https://tqdy06h5fq.feishu.cn/wiki/OWagweHaoiEYKWkCKEAcuMW6nMd">https://tqdy06h5fq.feishu.cn/wiki/OWagweHaoiEYKWkCKEAcuMW6nMd</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备寒假有空研究一下&lt;/p&gt;</summary>
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="资料" scheme="http://example.com/categories/ysyx/%E8%B5%84%E6%96%99/"/>
    
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="CPU设计" scheme="http://example.com/tags/CPU%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Makefile的常用操作</title>
    <link href="http://example.com/2024/01/21/tools/makefile%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2024/01/21/tools/makefile%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2024-01-20T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>如何将多个对象文件（.o文件，由${OBJS}变量表示）链接成一个可执行文件（os.elf），然后将该可执行文件转换成二进制格式的镜像文件（os.bin）<br>os.elf: ${OBJS}<br>    ${CC} ${CFLAGS} -T os.ld -o os.elf $^<br>    ${OBJCOPY} -O binary os.elf os.bin</p><p>-T os.ld：指定链接脚本os.ld。链接脚本用于控制链接过程，如指定各个段（如代码段、数据段）的位置。<br>-o os.elf：指定输出文件的名称为os.elf。<br>$^：这是Makefile的自动变量，表示所有的依赖项，这里指${OBJS}变量中列出的所有对象文件。</p><p>${OBJCOPY}：这是GNU Binutils工具集中objcopy程序的变量，用于进行文件格式转换。<br>-O binary：指定输出格式为二进制。objcopy可以将ELF格式（或其他格式）的文件转换为纯二进制格式，这对于裸机程序来说是必需的，因为硬件通常直接执行二进制代码。<br>os.elf：输入文件，即上一步生成的ELF格式的可执行文件。<br>os.bin：输出文件，转换成二进制格式后的文件名。</p><h4 id="定义编译核心数"><a href="#定义编译核心数" class="headerlink" title="定义编译核心数"></a>定义编译核心数</h4><p>NPROC:&#x3D; $(shell nproc 2&gt;&#x2F;dev&#x2F;null || echo 1)</p><p>这行Makefile代码定义了一个变量NPROC，它的目的是确定可以用于并行编译的处理器（CPU核心）数量。这个变量通常用于make命令的-j选项，以加速编译过程。让我们分解这行代码的各个部分：</p><p>$(shell …)：shell函数执行一个Shell命令，并将输出作为结果返回。在这个上下文中，它尝试执行nproc命令。</p><p>nproc：这是一个在多种Unix-like系统上可用的命令，用于打印系统上可用的处理单元数量（通常是CPU核心数量）。它是确定可用于并行编译作业数的常用方法。</p><p>2&gt;&#x2F;dev&#x2F;null：这部分将标准错误（stderr）重定向到&#x2F;dev&#x2F;null，意味着如果命令失败（例如，在某些环境中nproc命令不存在），错误信息不会被显示。</p><p>|| echo 1：这是一个逻辑或操作，如果nproc命令执行失败（返回非零退出状态），则执行echo 1。这意味着如果无法确定处理器数量，就假设只有1个可用的处理单元。</p><p>:&#x3D;$(shell …)：使用:&#x3D;进行变量赋值表示立即求值，这意味着NPROC变量将在Makefile解析时被设置为nproc命令的输出，或者在nproc不可用的情况下被设置为1。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>这些是GCC编译器的选项，用于控制编译过程的各个方面。以下是每个选项的简要解释：</p><h5 id="MMD"><a href="#MMD" class="headerlink" title="-MMD"></a><code>-MMD</code></h5><p>这个选项告诉编译器为每个源文件生成一个<code>.d</code>文件，其中包含了源文件中包含的头文件列表。这对于make工具自动解析文件依赖关系非常有用，帮助确保当头文件改变时，相关的源文件会被重新编译。</p><h5 id="Werror"><a href="#Werror" class="headerlink" title="-Werror"></a><code>-Werror</code></h5><p>将所有的警告转化为错误。这意味着，如果编译器发现任何警告，它将停止编译过程，并将这些警告视为错误处理。这有助于维持代码质量，确保开发者不会忽略编译器的警告。</p><h5 id="fno-asynchronous-unwind-tables"><a href="#fno-asynchronous-unwind-tables" class="headerlink" title="-fno-asynchronous-unwind-tables"></a><code>-fno-asynchronous-unwind-tables</code></h5><p>禁用生成异步异常展开表。这会减小生成的二进制文件大小，但可能会影响异常处理和程序调试。</p><h5 id="fno-builtin"><a href="#fno-builtin" class="headerlink" title="-fno-builtin"></a><code>-fno-builtin</code></h5><p>告诉编译器不要认为任何函数是内建的，即使编译器有内建的优化版本。这确保了对函数的调用不会被替换为编译器的内建版本，有助于避免潜在的优化导致的问题。</p><h5 id="fno-stack-protector"><a href="#fno-stack-protector" class="headerlink" title="-fno-stack-protector"></a><code>-fno-stack-protector</code></h5><p>禁用栈保护。默认情况下，GCC会为防止栈溢出攻击而插入特殊的安全检查代码。使用这个选项会禁用这些检查，可能会使得程序更容易受到栈溢出攻击。</p><h5 id="Wno-main"><a href="#Wno-main" class="headerlink" title="-Wno-main"></a><code>-Wno-main</code></h5><p>禁止关于<code>main</code>函数的警告。正常情况下，如果编译器发现<code>main</code>函数的声明不符合标准，会发出警告。这个选项会禁止这类警告。</p><h5 id="U-FORTIFY-SOURCE"><a href="#U-FORTIFY-SOURCE" class="headerlink" title="-U_FORTIFY_SOURCE"></a><code>-U_FORTIFY_SOURCE</code></h5><p>取消定义宏<code>_FORTIFY_SOURCE</code>。当定义了<code>_FORTIFY_SOURCE</code>宏时，GCC会启用一些额外的检查来防止缓冲区溢出等问题。使用<code>-U_FORTIFY_SOURCE</code>可以取消这些额外的检查。</p><h5 id="fvisibility-hidden"><a href="#fvisibility-hidden" class="headerlink" title="-fvisibility=hidden"></a><code>-fvisibility=hidden</code></h5><p>设置默认的符号可见性为隐藏。这意味着，除非显式地标记为可见，否则链接时不会导出符号。这有助于减小最终二进制文件的大小，并可能改善加载时间和防止符号冲突。</p><p>这些选项通常在构建需要精细控制编译过程的项目时使用，如操作系统内核、嵌入式系统或安全敏感的应用程序。它们有助于优化生成的代码，增强安全性和性能。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在Makefile中，GNU <code>make</code> 提供了一系列内置函数，用于处理文件名、目标对象和依赖项。这些函数可以帮助你简化规则的书写、处理字符串和文件名、以及执行列表的操作等。以下是一些处理目标对象时常用的函数：</p><h3 id="1-patsubst-pattern-replacement-text"><a href="#1-patsubst-pattern-replacement-text" class="headerlink" title="1. $(patsubst pattern,replacement,text)"></a>1. <code>$(patsubst pattern,replacement,text)</code></h3><p>用于模式字符串替换。它搜索<code>text</code>中的单词，将符合<code>pattern</code>的部分替换为<code>replacement</code>。</p><p>例子：将所有的<code>.c</code>文件扩展名替换为<code>.o</code>。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SRCS)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="2-wildcard-pattern"><a href="#2-wildcard-pattern" class="headerlink" title="2. $(wildcard pattern)"></a>2. <code>$(wildcard pattern)</code></h3><p>用于匹配符合<code>pattern</code>的文件名。</p><p>例子：获取当前目录下所有的<code>.c</code>文件。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br></pre></td></tr></table></figure><h3 id="3-dir-names"><a href="#3-dir-names" class="headerlink" title="3. $(dir names...)"></a>3. <code>$(dir names...)</code></h3><p>提取文件名列表<code>names</code>中每个文件的目录部分。</p><p>例子：获取所有源文件的目录。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRC_DIRS := <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$(SRCS)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="4-notdir-names"><a href="#4-notdir-names" class="headerlink" title="4. $(notdir names...)"></a>4. <code>$(notdir names...)</code></h3><p>从文件名列表<code>names</code>中去除所有的目录部分，只留下文件名。</p><p>例子：从完整路径列表中提取文件名。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRC_FILES := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(SRCS)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="5-addprefix-prefix-names"><a href="#5-addprefix-prefix-names" class="headerlink" title="5. $(addprefix prefix,names...)"></a>5. <code>$(addprefix prefix,names...)</code></h3><p>给<code>names</code>列表中的每个单词添加前缀<code>prefix</code>。</p><p>例子：给所有目标文件添加路径前缀。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJS := <span class="variable">$(<span class="built_in">addprefix</span> obj/,$(<span class="built_in">notdir</span> $(SRCS:.c=.o)</span>))</span><br></pre></td></tr></table></figure><h3 id="6-addsuffix-suffix-names"><a href="#6-addsuffix-suffix-names" class="headerlink" title="6. $(addsuffix suffix,names...)"></a>6. <code>$(addsuffix suffix,names...)</code></h3><p>给<code>names</code>列表中的每个单词添加后缀<code>suffix</code>。</p><p>例子：给所有模块名添加<code>.o</code>后缀。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOD_OBJS := <span class="variable">$(<span class="built_in">addsuffix</span> .o,<span class="variable">$(MODULES)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="7-filter-pattern-text"><a href="#7-filter-pattern-text" class="headerlink" title="7. $(filter pattern...,text)"></a>7. <code>$(filter pattern...,text)</code></h3><p>从<code>text</code>中选择符合<code>pattern</code>的单词。</p><p>例子：从所有文件中筛选出<code>.c</code>和<code>.h</code>文件。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C_AND_H_FILES := <span class="variable">$(<span class="built_in">filter</span> %.c %.h,<span class="variable">$(FILES)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="8-filter-out-pattern-text"><a href="#8-filter-out-pattern-text" class="headerlink" title="8. $(filter-out pattern...,text)"></a>8. <code>$(filter-out pattern...,text)</code></h3><p>从<code>text</code>中去除符合<code>pattern</code>的单词。</p><p>例子：从所有文件中去除<code>.o</code>文件。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NON_O_FILES := <span class="variable">$(<span class="built_in">filter</span>-out %.o,<span class="variable">$(FILES)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="9-sort-list"><a href="#9-sort-list" class="headerlink" title="9. $(sort list)"></a>9. <code>$(sort list)</code></h3><p>将<code>list</code>中的单词排序并去除重复的单词。</p><p>例子：排序并去重源文件列表。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNIQUE_SRCS := <span class="variable">$(<span class="built_in">sort</span> <span class="variable">$(SRCS)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="10-foreach-var-list-text"><a href="#10-foreach-var-list-text" class="headerlink" title="10. $(foreach var,list,text)"></a>10. <code>$(foreach var,list,text)</code></h3><p>对<code>list</code>中的每个单词执行<code>text</code>中的表达式，其中<code>var</code>作为当前单词的变量。</p><p>例子：为每个源文件打印一条编译信息。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> src,<span class="variable">$(SRCS)</span>,echo Compiling <span class="variable">$(src)</span>;)</span></span><br></pre></td></tr></table></figure><p>在Makefile中，使用一些高效的表达式和技巧可以大大提高构建系统的灵活性和可维护性。以下是一些常用的表达式和技巧，它们可以帮助你更有效地编写Makefile。</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="1-使用变量简化文件列表"><a href="#1-使用变量简化文件列表" class="headerlink" title="1. 使用变量简化文件列表"></a>1. 使用变量简化文件列表</h3><p>定义变量来简化文件列表的管理，使得在多个地方引用时不需要重复书写。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRCS := main.c foo.c bar.c</span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br></pre></td></tr></table></figure><p>这里，<code>.c</code>文件列表被赋值给<code>SRCS</code>变量，然后使用模式替换将<code>.c</code>后缀替换为<code>.o</code>生成对象文件列表，并赋值给<code>OBJS</code>变量。</p><h3 id="2-使用通配符自动获取文件列表"><a href="#2-使用通配符自动获取文件列表" class="headerlink" title="2. 使用通配符自动获取文件列表"></a>2. 使用通配符自动获取文件列表</h3><p>使用<code>wildcard</code>函数自动获取目录下的文件列表，避免手动列出。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SRCS := <span class="variable">$(<span class="built_in">wildcard</span> src/*.c)</span></span><br><span class="line">OBJS := $(SRCS:.c=.o)</span><br></pre></td></tr></table></figure><p>$(wildcard .config)是一个Makefile函数，用于查找当前目录下名为.config的文件。如果找到文件，则返回文件的完整路径；如果没有找到，则返回空。</p><h3 id="3-自动变量简化规则"><a href="#3-自动变量简化规则" class="headerlink" title="3. 自动变量简化规则"></a>3. 自动变量简化规则</h3><p>使用自动变量简化规则的书写。例如<code>$@</code>代表规则的目标，<code>$&lt;</code>代表第一个依赖，<code>$^</code>代表所有依赖。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app: <span class="variable">$(OBJS)</span></span></span><br><span class="line"><span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><h3 id="4-使用模式规则"><a href="#4-使用模式规则" class="headerlink" title="4. 使用模式规则"></a>4. 使用模式规则</h3><p>模式规则可以应用于匹配模式的目标，使得规则更加通用。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>这条规则表示任何<code>.o</code>文件都依赖于同名的<code>.c</code>文件，并描述了如何从<code>.c</code>文件构建<code>.o</code>文件。</p><p>$*，表示不带前缀的目标名称）<br>$&lt;，表示规则的第一个依赖</p><h3 id="5-条件判断"><a href="#5-条件判断" class="headerlink" title="5. 条件判断"></a>5. 条件判断</h3><p>使用条件判断来根据不同的条件选择不同的操作。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(DEBUG)</span>,yes)</span><br><span class="line">CFLAGS += -g</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">CFLAGS += -O2</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>根据<code>DEBUG</code>变量的值，调整编译标志。</p><h3 id="6-函数使用"><a href="#6-函数使用" class="headerlink" title="6. 函数使用"></a>6. 函数使用</h3><p>Makefile提供了许多内置函数，如<code>filter</code>、<code>patsubst</code>等，用于处理文本和文件名。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG_SRCS := <span class="variable">$(<span class="built_in">filter</span> %_debug.c,<span class="variable">$(SRCS)</span>)</span></span><br><span class="line">RELEASE_SRCS := <span class="variable">$(<span class="built_in">filter</span>-out %_debug.c,<span class="variable">$(SRCS)</span>)</span></span><br></pre></td></tr></table></figure><p>使用<code>filter</code>和<code>filter-out</code>函数来区分调试和发布的源文件。</p><h3 id="8-多目标规则"><a href="#8-多目标规则" class="headerlink" title="8. 多目标规则"></a>8. 多目标规则</h3><p>一个规则可以有多个目标，用于执行相同的命令序列构建多个目标。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: prog1 prog2</span></span><br></pre></td></tr></table></figure><h3 id="9-PHONY目标"><a href="#9-PHONY目标" class="headerlink" title="9. .PHONY目标"></a>9. .PHONY目标</h3><p>使用<code>.PHONY</code>声明伪目标，以避免与同名文件冲突。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f <span class="variable">$(OBJS)</span> app</span><br></pre></td></tr></table></figure><p>在Makefile中，处理字符串和变量的几个有用概念包括子集（<code>subset</code>）、单词（<code>word</code>）操作和变量类型的检查（<code>flavor</code>）。虽然Makefile本身不直接提供名为<code>subset</code>的函数，但是可以通过组合使用其他函数来实现子集选择等操作。下面是对<code>word</code>函数和<code>flavor</code>函数的解释，以及如何模拟实现子集选择的示例。</p><p>在Makefile中，$(subst from,to,text)函数用于文本替换，它在text字符串中将所有出现的from字符串替换为to字符串。在你提供的表达式：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH_SPLIT = <span class="variable">$(<span class="built_in">subst</span> -, ,<span class="variable">$(ARCH)</span>)</span></span><br></pre></td></tr></table></figure><p>这行代码的作用是将变量ARCH中的所有破折号（-）替换为空格。这种替换通常用于处理类似于x86_64-linux-gnu这样的复合体系结构名称或其他用破折号连接的字符串，目的是将它们拆分为由空格分隔的单词列表，以便于后续操作或查询。</p><h3 id="word-函数"><a href="#word-函数" class="headerlink" title="word 函数"></a>word 函数</h3><p><code>word</code>函数用于从以空格分隔的单词列表中选取第<code>n</code>个单词。其语法如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> n,text)</span></span><br></pre></td></tr></table></figure><ul><li><code>n</code>是要选取的单词的位置（从1开始计数）。</li><li><code>text</code>是单词列表。</li></ul><p>例如，如果你有一个文件列表，想要选取第二个文件名，可以这样做：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILES := file1.c file2.c file3.c</span><br><span class="line">SECOND_FILE := <span class="variable">$(<span class="built_in">word</span> 2,<span class="variable">$(FILES)</span>)</span></span><br></pre></td></tr></table></figure><p>这里，<code>SECOND_FILE</code>的值将是<code>file2.c</code>。</p><h3 id="flavor-函数"><a href="#flavor-函数" class="headerlink" title="flavor 函数"></a>flavor 函数</h3><p><code>flavor</code>函数用于查询变量的类型。Makefile中的变量可以是简单展开的（<code>simple</code>）、递归展开的（<code>recursive</code>）、环境变量（<code>environment</code>）、命令行定义的（<code>command line</code>）等。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">flavor</span> variable-name)</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VAR := simple</span><br><span class="line">VAR2 = recursive</span><br><span class="line"><span class="variable">$(info $(<span class="built_in">flavor</span> VAR)</span>)  <span class="comment"># 输出 simple</span></span><br><span class="line"><span class="variable">$(info $(<span class="built_in">flavor</span> VAR2)</span>) <span class="comment"># 输出 recursive</span></span><br></pre></td></tr></table></figure><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>override ARGS ?&#x3D; …行使用了条件赋值操作符?&#x3D;, 它只在ARGS未定义时设置值。override关键字用于确保即使在命令行中定义了ARGS变量，这个赋值也会生效。</p><h3 id=""><a href="#" class="headerlink" title="::"></a>::</h3><p>$(BINARY):: compile_git<br>这里定义了一个目标$(BINARY)，它有一个额外的依赖compile_git。$(BINARY)很可能是一个变量，表示要构建的二进制文件的名字。使用::而不是单个:定义规则，表示这是一个终端规则（Terminal Rule），它允许同一个目标有多个独立的规则定义，这些规则都会被执行。</p><h2 id="MAKE"><a href="#MAKE" class="headerlink" title="$(MAKE)"></a>$(MAKE)</h2><p>$(MAKE) -C $(NEMU_HOME):</p><p>$(MAKE)是一个特殊变量，代表make工具的名称，通常就是make。这允许在Makefile中递归地调用make。<br>-C $(NEMU_HOME)选项告诉make更改到目录$(NEMU_HOME)然后执行后续的make操作。$(NEMU_HOME)应该是一个变量，它指定了NEMU（一个可能的模拟器或工具链）的根目录。</p><h2 id="if-s"><a href="#if-s" class="headerlink" title="if [-s.. ]"></a>if [-s.. ]</h2><p>在 shell 脚本中，[ -s … ] 是一个条件测试，用于检查文件的大小是否非零（即文件是否存在且至少有一个字节）。-s 是这个测试中的特定选项。</p><p>除了 -s 之外，还有很多其他的文件测试操作符可以在 [ … ] 或 [[ … ]] 中使用（注意 [ 和 ] 之间应有空格）。以下是一些常见的文件测试操作符：</p><pre><code>-e：文件存在-f：文件是一个常规文件（不是目录、设备文件等）-d：文件是一个目录-r：文件存在且可读-w：文件存在且可写-x：文件存在且可执行-L：文件是一个符号链接-S：文件是一个套接字-b：文件是一个块特殊文件-c：文件是一个字符特殊文件-p：文件是一个命名管道（FIFO）-N：文件自上次读取后已被修改-O：文件由当前用户拥有-G：文件的组与当前用户相同</code></pre><p>此外，还有一些数字比较和字符串比较操作符等。</p><p>例如，如果你想检查一个文件是否存在并且是一个目录，你可以使用：</p><p>bash<br>if [ -d “&#x2F;path&#x2F;to&#x2F;directory” ]; then<br>    echo “It’s a directory!”<br>fi</p><p>希望这能帮助你理解 [ … ] 中的各种文件测试操作符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h2&gt;&lt;h4 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    <category term="build" scheme="http://example.com/categories/tools/build/"/>
    
    
    <category term="Makefile" scheme="http://example.com/tags/Makefile/"/>
    
    <category term="编译构建" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E6%9E%84%E5%BB%BA/"/>
    
    <category term="自动化工具" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>高级开发软件配置指南</title>
    <link href="http://example.com/2023/12/26/tools/%E9%85%8D%E7%BD%AE%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6/"/>
    <id>http://example.com/2023/12/26/tools/%E9%85%8D%E7%BD%AE%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6/</id>
    <published>2023-12-25T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了一些高级开发软件的配置方法，包括VSCode与Vivado的集成、项目导入等内容。</p><span id="more"></span><h2 id="VSCode关联VIVADO编辑Verilog"><a href="#VSCode关联VIVADO编辑Verilog" class="headerlink" title="VSCode关联VIVADO编辑Verilog"></a>VSCode关联VIVADO编辑Verilog</h2><p><a href="https://blog.csdn.net/wd12306/article/details/128929552">https://blog.csdn.net/wd12306/article/details/128929552</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>导入的文件可以不在{projectdir}\newcounter\newcounter.srcs中，<br><img src="/../images/%E9%85%8D%E7%BD%AEvivado/image.png" alt="Alt text"></p><h2 id="vivado加入board和part"><a href="#vivado加入board和part" class="headerlink" title="vivado加入board和part"></a>vivado加入board和part</h2><p><a href="https://support.xilinx.com/s/question/0D52E00006lLBqpSAG/setting-board-file-fails-with-error-board-4971-the-boardpart-definition-was-not-found?language=en_US">https://support.xilinx.com/s/question/0D52E00006lLBqpSAG/setting-board-file-fails-with-error-board-4971-the-boardpart-definition-was-not-found?language=en_US</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍了一些高级开发软件的配置方法，包括VSCode与Vivado的集成、项目导入等内容。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    <category term="开发环境" scheme="http://example.com/categories/tools/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="开发工具" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="VSCode" scheme="http://example.com/tags/VSCode/"/>
    
    <category term="Vivado" scheme="http://example.com/tags/Vivado/"/>
    
    <category term="环境配置" scheme="http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>硬件安全学习资源汇总</title>
    <link href="http://example.com/2023/12/10/course/%E5%AD%A6%E4%B9%A0%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>http://example.com/2023/12/10/course/%E5%AD%A6%E4%B9%A0%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%AB%99/</id>
    <published>2023-12-09T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集和整理硬件安全领域的学习资源，包括网站、工具、教程等内容。</p><p>作为一名信息安全的学生，由于更喜欢与真实的世界打交道，选择了深入了解硬件安全。这里就将用来记录一些关于<em>硬件安全</em>的学习网站</p><span id="more"></span><h2 id="黑客平台"><a href="#黑客平台" class="headerlink" title="黑客平台"></a>黑客平台</h2><h4 id="包含多层面的安全技术，其中有IoT安全"><a href="#包含多层面的安全技术，其中有IoT安全" class="headerlink" title="包含多层面的安全技术，其中有IoT安全"></a>包含多层面的安全技术，其中有IoT安全</h4><p><a href="https://paper.seebug.org/">https://paper.seebug.org/</a></p><h2 id="keystone"><a href="#keystone" class="headerlink" title="keystone"></a>keystone</h2><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p><a href="http://docs.keystone-enclave.org/en/latest/">http://docs.keystone-enclave.org/en/latest/</a></p><h4 id="【TEE自学随笔】keystone代码略读"><a href="#【TEE自学随笔】keystone代码略读" class="headerlink" title="【TEE自学随笔】keystone代码略读"></a>【TEE自学随笔】keystone代码略读</h4><p><a href="https://blog.csdn.net/BOWS7RING/article/details/116906211?spm=1001.2014.3001.5502">https://blog.csdn.net/BOWS7RING/article/details/116906211?spm=1001.2014.3001.5502</a></p><h4 id="一文知悉RISC-V可信执行环境：Keystone"><a href="#一文知悉RISC-V可信执行环境：Keystone" class="headerlink" title="一文知悉RISC-V可信执行环境：Keystone"></a>一文知悉RISC-V可信执行环境：Keystone</h4><p><a href="https://blog.csdn.net/weixin_45264425/article/details/134326170">https://blog.csdn.net/weixin_45264425/article/details/134326170</a></p><h2 id="trustzone"><a href="#trustzone" class="headerlink" title="trustzone"></a>trustzone</h2><h4 id="ARM-A64架构TrustZone学习"><a href="#ARM-A64架构TrustZone学习" class="headerlink" title="ARM A64架构TrustZone学习"></a>ARM A64架构TrustZone学习</h4><p><a href="https://blog.csdn.net/pslyunhai3255/article/details/129229732">https://blog.csdn.net/pslyunhai3255/article/details/129229732</a></p><h2 id="侧信道攻击"><a href="#侧信道攻击" class="headerlink" title="侧信道攻击"></a>侧信道攻击</h2><h4 id="RISC-V-CPU侧信道攻击原理与实践"><a href="#RISC-V-CPU侧信道攻击原理与实践" class="headerlink" title="RISC-V CPU侧信道攻击原理与实践"></a>RISC-V CPU侧信道攻击原理与实践</h4><p><a href="https://www.zhihu.com/people/shawn-82-88-4">https://www.zhihu.com/people/shawn-82-88-4</a></p><h2 id="数字ic"><a href="#数字ic" class="headerlink" title="数字ic"></a>数字ic</h2><h4 id="手把手教你蜂鸟e203移植（以Nexys4DDR为例）"><a href="#手把手教你蜂鸟e203移植（以Nexys4DDR为例）" class="headerlink" title="手把手教你蜂鸟e203移植（以Nexys4DDR为例）"></a>手把手教你蜂鸟e203移植（以Nexys4DDR为例）</h4><p><a href="https://www.cnblogs.com/Qzzz/p/17201475.html">https://www.cnblogs.com/Qzzz/p/17201475.html</a></p><h4 id="数字IC基础学这些就够了"><a href="#数字IC基础学这些就够了" class="headerlink" title="数字IC基础学这些就够了"></a>数字IC基础学这些就够了</h4><p><a href="https://zhuanlan.zhihu.com/p/670736813">https://zhuanlan.zhihu.com/p/670736813</a></p><h4 id="国产安全芯片，请关注他们！"><a href="#国产安全芯片，请关注他们！" class="headerlink" title="国产安全芯片，请关注他们！"></a>国产安全芯片，请关注他们！</h4><p><a href="https://zhuanlan.zhihu.com/p/627643776">https://zhuanlan.zhihu.com/p/627643776</a></p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h4 id="计算机体系结构学习路线"><a href="#计算机体系结构学习路线" class="headerlink" title="计算机体系结构学习路线"></a>计算机体系结构学习路线</h4><p><a href="https://zhuanlan.zhihu.com/p/654821469">https://zhuanlan.zhihu.com/p/654821469</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;收集和整理硬件安全领域的学习资源，包括网站、工具、教程等内容。&lt;/p&gt;
&lt;p&gt;作为一名信息安全的学生，由于更喜欢与真实的世界打交道，选择了深入了解硬件安全。这里就将用来记录一些关于&lt;em&gt;硬件安全&lt;/em&gt;的学习网站&lt;/p&gt;</summary>
    
    
    
    <category term="course" scheme="http://example.com/categories/course/"/>
    
    <category term="硬件安全" scheme="http://example.com/categories/course/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="课程笔记" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="硬件安全" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    
    <category term="安全设计" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="学习资源" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread内存管理分析</title>
    <link href="http://example.com/2023/12/07/ysyx/rtthread/%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2023/12/07/ysyx/rtthread/%E5%86%85%E5%AD%98/</id>
    <published>2023-12-06T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>RT-Thread操作系统内存管理机制的分析，以及相关开发环境配置和调试工具的使用说明。</p><span id="more"></span><h1 id="把ubuntu升级到22了"><a href="#把ubuntu升级到22了" class="headerlink" title="把ubuntu升级到22了"></a>把ubuntu升级到22了</h1><p>sudo sed -i ‘s&#x2F;focal&#x2F;jammy&#x2F;g’ &#x2F;etc&#x2F;apt&#x2F;sources.list<br>sudo apt update<br>sudo apt upgrade<br>sudo apt dist-upgrade</p><h1 id="重启后连不上网了"><a href="#重启后连不上网了" class="headerlink" title="重启后连不上网了"></a>重启后连不上网了</h1><ol><li>查看所有网络接口的状态：<br>ip link show</li><li>检查它们是否为 DOWN 状态（关闭状态），如果是，可以尝试启用它们<br>sudo ip link set eth0 up</li><li>网络接口可能未正确配置 IP 地址。可以尝试动态分配 IP：<br>sudo dhclient eth0</li></ol><h1 id="cland配置运行命令"><a href="#cland配置运行命令" class="headerlink" title="cland配置运行命令"></a>cland配置运行命令</h1><p>bear – &lt;编译需要的命令&gt;</p><h1 id="addressSentiser"><a href="#addressSentiser" class="headerlink" title="addressSentiser"></a>addressSentiser</h1><p>直接定位段错误的位置，除了地址越界的错误之外, Address Sanitizer还能检查use-after-free的错误<br>GCC提供了一个-fsanitize&#x3D;address的编译选项来启用它<br><img src="/image.png" alt="alt text"></p><p>GCC还支持更多的sanitizer, 它们可以检查各种不同的错误, 你可以在man gcc中查阅-fsanitize相关的选项</p><h1 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h1><p> Valgrind is a very powerful tool for such a need. Run rltest with valgrind:<br>$ valgrind .&#x2F;rltest</p><h1 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h1><p>安装<br>sudo apt-get update<br>sudo apt-get install linux-tools-common linux-tools-generic linux-tools-$(uname -r)</p><h1 id="linux上的slab"><a href="#linux上的slab" class="headerlink" title="linux上的slab"></a>linux上的slab</h1><p><a href="https://segmentfault.com/a/1190000043626203">https://segmentfault.com/a/1190000043626203</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RT-Thread操作系统内存管理机制的分析，以及相关开发环境配置和调试工具的使用说明。&lt;/p&gt;</summary>
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="RTOS" scheme="http://example.com/categories/ysyx/RTOS/"/>
    
    
    <category term="内存管理" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="RT-Thread" scheme="http://example.com/tags/RT-Thread/"/>
    
    <category term="实时操作系统" scheme="http://example.com/tags/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CPU时序校准与延迟优化</title>
    <link href="http://example.com/2023/12/03/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%A0%A1%E5%87%86%E5%BB%B6%E8%BF%9F/"/>
    <id>http://example.com/2023/12/03/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%A0%A1%E5%87%86%E5%BB%B6%E8%BF%9F/</id>
    <published>2023-12-02T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要校准"><a href="#为什么要校准" class="headerlink" title="为什么要校准"></a>为什么要校准</h2><p>事实上, 之前的ysyxSoC环境是假设处理器和各种外设运行在同一频率下: verilator仿真的一个周期, 既是处理器中的一个周期, 也是外设中的一个周期. 但实际上并非如此: 受电气特性的影响, 外设通常只能运行在低频率, 例如SDRAM颗粒通常只能运行在100MHz左右, 过高的频率会导致时序违例, 使得SDRAM颗粒无法正确工作; 但另一方面, 使用先进工艺的处理器通常能够运行在更高的频率, 例如, yzh某个版本的多周期NPC在yosys-sta项目默认提供的nangate45工艺下频率达到约1.2GHz. 在上述配置下, SDRAM控制器中经过1个周期, NPC应该经过12个周期, 但verilator感知不到两者的频率差异, 仍然按照两者频率相同的假设进行仿真, 使得仿真结果比真实芯片乐观很多, 从而也可能会使得一些优化措施无法在真实芯片中取得预期的效果.</p><h2 id="我的仿真频率"><a href="#我的仿真频率" class="headerlink" title="我的仿真频率"></a>我的仿真频率</h2><table><thead><tr><th>Endpoint</th><th>Clock Group</th><th>Delay Type</th><th>Path Delay</th><th>Path Required</th><th>CPPR</th><th>Slack</th><th>Freq(MHz)</th></tr></thead><tbody><tr><td>clint&#x2F;<em>1870</em>:D</td><td>core_clock</td><td>max</td><td>1.984r</td><td>9.969</td><td>0.000</td><td>7.985</td><td>496.197</td></tr><tr><td>clint&#x2F;<em>1870</em>:D</td><td>core_clock</td><td>max</td><td>1.966f</td><td>9.961</td><td>0.000</td><td>7.995</td><td>498.797</td></tr><tr><td>clint&#x2F;<em>1869</em>:D</td><td>core_clock</td><td>max</td><td>1.959f</td><td>9.961</td><td>0.000</td><td>8.001</td><td>500.367</td></tr><tr><td>exu&#x2F;u_alu&#x2F;<em>2689</em>:D</td><td>core_clock</td><td>min</td><td>0.079f</td><td>0.002</td><td>0.000</td><td>0.078</td><td>NA</td></tr><tr><td>exu&#x2F;u_alu&#x2F;<em>2689</em>:D</td><td>core_clock</td><td>min</td><td>0.086r</td><td>0.006</td><td>0.000</td><td>0.080</td><td>NA</td></tr><tr><td>registerfile&#x2F;<em>7836</em>:D</td><td>core_clock</td><td>min</td><td>0.114f</td><td>0.002</td><td>0.000</td><td>0.112</td><td>NA</td></tr></tbody></table><h2 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h2><p>我的校准系数是5</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要校准&quot;&gt;&lt;a href=&quot;#为什么要校准&quot; class=&quot;headerlink&quot; title=&quot;为什么要校准&quot;&gt;&lt;/a&gt;为什么要校准&lt;/h2&gt;&lt;p&gt;事实上, 之前的ysyxSoC环境是假设处理器和各种外设运行在同一频率下: verilator仿真的一个周期</summary>
      
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="性能优化" scheme="http://example.com/categories/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="CPU设计" scheme="http://example.com/tags/CPU%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="时序优化" scheme="http://example.com/tags/%E6%97%B6%E5%BA%8F%E4%BC%98%E5%8C%96/"/>
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CPU功能测试与验证</title>
    <link href="http://example.com/2023/12/03/ysyx/abstract-machine/cpu-test/"/>
    <id>http://example.com/2023/12/03/ysyx/abstract-machine/cpu-test/</id>
    <published>2023-12-02T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>CPU功能测试过程中遇到的问题及解决方案，包括longlong测试、内存对齐等问题的分析。</p><span id="more"></span><h2 id="longlong-的cpu测试有时候过不了"><a href="#longlong-的cpu测试有时候过不了" class="headerlink" title="longlong 的cpu测试有时候过不了"></a>longlong 的cpu测试有时候过不了</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> test_data[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0x7fffffffffffffff</span>LL, <span class="number">0x8000000000000000</span>LL, <span class="number">0x8000000000000001</span>LL, <span class="number">0xfffffffffffffffe</span>LL, <span class="number">0xffffffffffffffff</span>LL&#125;;</span><br></pre></td></tr></table></figure><h3 id="longlong的打印"><a href="#longlong的打印" class="headerlink" title="longlong的打印"></a>longlong的打印</h3><p>在处理 long long 类型的负数时，特别是极值（如 0x8000000000000000LL），直接取反操作 value &#x3D; -value; 可能会导致溢出问题。因为 0x8000000000000000LL 是 long long 类型的最小值，其绝对值超出了 long long 类型的正数范围<br><img src="/image.png" alt="alt text"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> value;</span><br><span class="line">   <span class="comment">// Set &#x27;-&#x27; for negative decimals.</span></span><br><span class="line">   <span class="keyword">if</span> (value &lt; <span class="number">0</span> &amp;&amp; base == <span class="number">10</span>) &#123;</span><br><span class="line">       *str++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">       value = -value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用无符号类型：在处理负数时，将其转换为无符号类型 unsigned long long，以避免溢出问题。<br><img src="/image-1.png" alt="alt text"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uvalue;</span><br><span class="line">   <span class="comment">// Set &#x27;-&#x27; for negative decimals.</span></span><br><span class="line">   <span class="keyword">if</span> (value &lt; <span class="number">0</span> &amp;&amp; base == <span class="number">10</span>) &#123;</span><br><span class="line">       *str++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">       uvalue = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(-value);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       uvalue = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="longlong必须8字节对齐"><a href="#longlong必须8字节对齐" class="headerlink" title="longlong必须8字节对齐"></a>longlong必须8字节对齐</h3><p>如果只是四字节对齐的话，longlong的指针8字节对齐，但flash中存储的longlong数据不会8字节对齐。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.data : &#123;</span><br><span class="line">  _data_start = .;</span><br><span class="line">  *(.data*)</span><br><span class="line">  *(.sdata*)</span><br><span class="line">  /* *(.data) */</span><br><span class="line">  _data_end = .;</span><br><span class="line">   . = ALIGN(4);</span><br><span class="line">&#125; &gt; sdram AT &gt;flash</span><br></pre></td></tr></table></figure><p>可以看到数组指针8字节对齐，但数组数据没有<br><img src="/image-2.png" alt="alt text"><br>通过8字节对齐，让longlong对齐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.data : &#123;</span><br><span class="line">  _data_start = .;</span><br><span class="line">  *(.data*)</span><br><span class="line">  *(.sdata*)</span><br><span class="line">  /* *(.data) */</span><br><span class="line">  _data_end = .;</span><br><span class="line">   . = ALIGN(8);</span><br><span class="line">&#125; &gt; sdram AT &gt;flash</span><br></pre></td></tr></table></figure><p><img src="/image-3.png" alt="alt text"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="/image-4.png" alt="alt text"></p><h2 id="4-2-1访存未对齐"><a href="#4-2-1访存未对齐" class="headerlink" title="4-2-1访存未对齐"></a>4-2-1访存未对齐</h2><h4 id="问题现象展示"><a href="#问题现象展示" class="headerlink" title="问题现象展示"></a>问题现象展示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a0000180:fe042823          swzero,-16(s0)</span><br><span class="line">a0000184:0900006f          ja0000214 &lt;main+0x1d0&gt;</span><br><span class="line">a0000188:ff042783          lwa5,-16(s0)</span><br><span class="line">a000018c:00279793          slla5,a5,0x2</span><br><span class="line">a0000190:00178713          adda4,a5,1</span><br><span class="line">a0000194:00001797          auipca5,0x1</span><br><span class="line">a0000198:4ec78793          adda5,a5,1260 # a0001680 &lt;mem&gt;</span><br><span class="line">a000019c:00f707b3          adda5,a4,a5</span><br><span class="line">a00001a0:0007a783          lwa5,0(a5)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> mem[] = &#123;</span><br><span class="line"><span class="number">0x0</span>, <span class="number">0x0258</span>, <span class="number">0x4abc</span>, <span class="number">0x7fff</span>, <span class="number">0x8000</span>, <span class="number">0x8100</span>, <span class="number">0xabcd</span>, <span class="number">0xffff</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span>  lwlr_ans[] = &#123;</span><br><span class="line"><span class="number">0xbc025800</span>, <span class="number">0x7fff4a</span>, <span class="number">0xcd810080</span>, <span class="number">0xffffab</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ((LENGTH(mem) / <span class="number">2</span>) - <span class="number">1</span>); i ++) &#123;</span><br><span class="line"><span class="type">unsigned</span> x = ((<span class="type">unsigned</span>*)((<span class="type">void</span>*)mem + <span class="number">1</span>))[i];</span><br><span class="line"><span class="type">unsigned</span> y = lwlr_ans[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%x,y=%x\n&quot;</span>,x,y);</span><br><span class="line">check(x == lwlr_ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image-6.png" alt="alt text"><br><img src="/image-5.png" alt="alt text"><br>使用nemu编译实锤编译出了非对齐访存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mtrace] read data 0xbc025800 from pmem 0x800012d5</span><br><span class="line">[mtrace] read data 0xfef42223 from pmem 0x80000178</span><br><span class="line">[mtrace] write data 0xbc025800 to pmem 0x80009fd4</span><br></pre></td></tr></table></figure><p>difftest忘开了，不然也不至于找这么半天<br><img src="/image-7.png" alt="alt text"></p><h4 id="gcc开启参数-mstrict-align"><a href="#gcc开启参数-mstrict-align" class="headerlink" title="gcc开启参数-mstrict-align"></a>gcc开启参数-mstrict-align</h4><p>但是使用下面编译器，参数无效，还能编译出非对齐访存，得使用上面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE := /opt/riscv/bin/riscv64-unknown-elf-</span><br><span class="line">#CROSS_COMPILE := /opt/riscv/bin/riscv64-unknown-linux-gnu-</span><br><span class="line">COMMON_CFLAGS := -fno-pic -march=rv64g -mcmodel=medany -mstrict-align</span><br></pre></td></tr></table></figure><h4 id="发现是写内存代码有问题，解决了就好了，编译器都可以使"><a href="#发现是写内存代码有问题，解决了就好了，编译器都可以使" class="headerlink" title="发现是写内存代码有问题，解决了就好了，编译器都可以使"></a>发现是写内存代码有问题，解决了就好了，编译器都可以使</h4><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>直接#include&lt;stido.h&gt;就是使用的gnu的stdio.h</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CPU功能测试过程中遇到的问题及解决方案，包括longlong测试、内存对齐等问题的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="验证测试" scheme="http://example.com/categories/ysyx/%E9%AA%8C%E8%AF%81%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="CPU测试" scheme="http://example.com/tags/CPU%E6%B5%8B%E8%AF%95/"/>
    
    <category term="功能验证" scheme="http://example.com/tags/%E5%8A%9F%E8%83%BD%E9%AA%8C%E8%AF%81/"/>
    
    <category term="Abstract Machine" scheme="http://example.com/tags/Abstract-Machine/"/>
    
  </entry>
  
  <entry>
    <title>ICache实现与优化</title>
    <link href="http://example.com/2023/12/01/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/icache/"/>
    <id>http://example.com/2023/12/01/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/icache/</id>
    <published>2023-11-30T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>变成两路后好像负优化了<br><img src="/image.png" alt="alt text"></p><p>Icache配置切换</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">IcacheConfig</span></span>&#123;</span><br><span class="line">  <span class="comment">//Byte</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">BlockSize</span>: <span class="type">Int</span> = <span class="number">8</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">WayNum</span> : <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">SetNum</span>: <span class="type">Int</span> = <span class="number">16</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">Strategy</span>: <span class="type">String</span> = <span class="string">&quot;RANDOM&quot;</span> <span class="comment">//LRU,FIFO</span></span><br><span class="line">  <span class="keyword">val</span> burst: <span class="type">String</span> = <span class="string">&quot;INCR&quot;</span> <span class="comment">//INCR,WRAP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Icache的控制参数"><a href="#Icache的控制参数" class="headerlink" title="Icache的控制参数"></a>Icache的控制参数</h1><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span>         _GEN = state == <span class="number">3&#x27;h0</span>;<span class="comment">// @[src/main/AXI/AXI4.scala:162:24, :182:19]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_0 = state == <span class="number">3&#x27;h1</span>;<span class="comment">// @[src/main/AXI/AXI4.scala:162:24, :182:19, :193:17]</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]   _GEN_1 = &#123;<span class="number">5&#x27;h0</span>, sizeReg&#125;;<span class="comment">// @[src/main/AXI/AXI4.scala:143:56, :167:22]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_2 = _GEN | ~_GEN_0;<span class="comment">// @[src/main/AXI/AXI4.scala:62:17, :182:19]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_3 = state == <span class="number">3&#x27;h2</span>;<span class="comment">// @[src/main/AXI/AXI4.scala:162:24, :182:19, :187:15]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_4 = _GEN | _GEN_0;<span class="comment">// @[src/main/AXI/AXI4.scala:52:18, :182:19]</span></span><br><span class="line"><span class="keyword">wire</span>         io_axi_wvalid_0 = ~_GEN_4 &amp; _GEN_3;<span class="comment">// @[src/main/AXI/AXI4.scala:52:18, :182:19]</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>]   _wstrbReg_T = <span class="number">8&#x27;h1</span> &lt;&lt; _GEN_1;<span class="comment">// @[src/main/AXI/AXI4.scala:143:56, src/main/Cache/Icache.scala:94:26]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_5 = _GEN_4 | ~_GEN_3;<span class="comment">// @[src/main/AXI/AXI4.scala:48:17, :52:18, :182:19]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_6 = idx_beat == lenReg;<span class="comment">// @[src/main/AXI/AXI4.scala:168:21, :170:23, :227:23]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_7 = io_axi_awready &amp; io_axi_wready;<span class="comment">// @[src/main/AXI/AXI4.scala:231:27]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_8 = state == <span class="number">3&#x27;h3</span>;<span class="comment">// @[src/main/AXI/AXI4.scala:162:24, :182:19, :210:17]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_9 = _GEN | _GEN_0 | _GEN_3;<span class="comment">// @[src/main/AXI/AXI4.scala:68:17, :182:19]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_10 = _GEN_8 &amp; io_axi_rvalid;<span class="comment">// @[src/main/AXI/AXI4.scala:174:19, :182:19, :244:29, :246:27]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_11 = io_axi_rlast | _GEN_6;<span class="comment">// @[src/main/AXI/AXI4.scala:227:23, :248:29]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_12 = state == <span class="number">3&#x27;h4</span>;<span class="comment">// @[src/main/AXI/AXI4.scala:153:38, :162:24, :182:19]</span></span><br><span class="line"><span class="keyword">wire</span>         _GEN_13 = _GEN_8 | ~_GEN_12;<span class="comment">// @[src/main/AXI/AXI4.scala:55:16, :182:19]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;变成两路后好像负优化了&lt;br&gt;&lt;img src=&quot;/image.png&quot; alt=&quot;alt text&quot;&gt;&lt;/p&gt;
&lt;p&gt;Icache配置切换&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="性能优化" scheme="http://example.com/categories/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="CPU设计" scheme="http://example.com/tags/CPU%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="Cache" scheme="http://example.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>AXI4总线协议详解</title>
    <link href="http://example.com/2023/11/30/ysyx/%E6%80%BB%E7%BA%BF/axi4/"/>
    <id>http://example.com/2023/11/30/ysyx/%E6%80%BB%E7%BA%BF/axi4/</id>
    <published>2023-11-29T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wlast"><a href="#wlast" class="headerlink" title="wlast"></a>wlast</h2><p>使用sdram-axi后，写入flash出现的问题。xbar的auto_in没问题，但in_0的awvalid没有置1<br><img src="/image.png" alt="alt text"></p><p>用到了队列，但io_deq_ready一直没有激活，一直无法从队列中弹出第一次axi事务的信号。<br><img src="/image-3.png" alt="alt text"><br>原因是wlast用于指示最后一个axi的transfer.如果只有一个transfer，那wlast要和wvalid同时为1<br><img src="/image-2.png" alt="alt text"><br>加上提前wlast的信号</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">when(idx_beat === num_beats(lenReg) <span class="number">-1.</span><span class="type">U</span>)&#123;</span><br><span class="line">axi4.wlast := <span class="literal">true</span>.<span class="type">B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="突发传输"><a href="#突发传输" class="headerlink" title="突发传输"></a>突发传输</h2><p>一次事务的结束以rlast&#x2F;wlast为标志，cpu中xbar和arbiter要做修改,在收到rlast&#x2F;wlast时切换道空闲状态。否则cpu中总线收不到rlast&#x2F;wlast<br><img src="/image-1.png" alt="alt text"></p><h2 id="写的信号关系"><a href="#写的信号关系" class="headerlink" title="写的信号关系"></a>写的信号关系</h2><p>1.master的wvalid不能依赖awready<br><img src="/image-4.png" alt="alt text"></p><h2 id="sdram的突发"><a href="#sdram的突发" class="headerlink" title="sdram的突发"></a>sdram的突发</h2><p>assign wlast_o &#x3D; axi_wlast_i;<br>assign rlast_o &#x3D; !resp_is_last_w | axi_arlen_i&#x3D;&#x3D;8’d0;<br>下图的state_q应该只用一个周期。一个周期后req_len_q&#x3D;&#x3D;ff,晚了一个周期。因此只能使用axi_arlen_i<br><img src="/image-7.png" alt="alt text"><br>突发成功了和突发没成功<br><img src="/image-6.png" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;wlast&quot;&gt;&lt;a href=&quot;#wlast&quot; class=&quot;headerlink&quot; title=&quot;wlast&quot;&gt;&lt;/a&gt;wlast&lt;/h2&gt;&lt;p&gt;使用sdram-axi后，写入flash出现的问题。xbar的auto_in没问题，但in_0的awvalid没有置</summary>
      
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="总线" scheme="http://example.com/categories/ysyx/%E6%80%BB%E7%BA%BF/"/>
    
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="AXI4" scheme="http://example.com/tags/AXI4/"/>
    
    <category term="总线协议" scheme="http://example.com/tags/%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="硬件设计" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>其他开源SoC项目研究</title>
    <link href="http://example.com/2023/11/29/ysyx/ysyxsoc/%E5%85%B6%E4%BB%96soc/"/>
    <id>http://example.com/2023/11/29/ysyx/ysyxsoc/%E5%85%B6%E4%BB%96soc/</id>
    <published>2023-11-28T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究和分析其他开源SoC项目的设计和实现，包括外设接口和系统架构。</p><span id="more"></span><h2 id="uart"><a href="#uart" class="headerlink" title="uart"></a>uart</h2><p>void putch(char ch) {<br>while (!(inb(UART16550_BASE + UART_LINE_STA_R) &amp; 0b00100000));<br>&#x2F;&#x2F;<strong>difftest时需注释外设的输入信号</strong>，不用注释了，因为difftest跳过外设的输入输出<br>  outb(UART16550_BASE, ch);<br>}</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究和分析其他开源SoC项目的设计和实现，包括外设接口和系统架构。&lt;/p&gt;</summary>
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="SoC设计" scheme="http://example.com/categories/ysyx/SoC%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="RISC-V" scheme="http://example.com/tags/RISC-V/"/>
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="SoC" scheme="http://example.com/tags/SoC/"/>
    
    <category term="开源硬件" scheme="http://example.com/tags/%E5%BC%80%E6%BA%90%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>SDRAM控制器实现</title>
    <link href="http://example.com/2023/11/29/ysyx/ysyxsoc/sdram/"/>
    <id>http://example.com/2023/11/29/ysyx/ysyxsoc/sdram/</id>
    <published>2023-11-28T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDRAM控制器的实现与优化，包括配置切换、时序控制、突发传输等功能的详细说明。</p><span id="more"></span><h1 id="sdram配置切换"><a href="#sdram配置切换" class="headerlink" title="sdram配置切换"></a>sdram配置切换</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">SDRAMConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">SDRAM_2BYTE_NUM</span>: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">SDRAM_WORD_NUM</span>: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> awidth = <span class="keyword">if</span> (<span class="type">SDRAM_WORD_NUM</span> == <span class="number">2</span>) <span class="number">14</span> <span class="keyword">else</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> SDRAM_2BYTE_NUM             = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">parameter</span> SDRAM_WORD_NUM             = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>只有在使用sdram_axi时，才可以突发访问</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="设置寄存器"><a href="#设置寄存器" class="headerlink" title="设置寄存器"></a>设置寄存器</h2><p><img src="/image.png" alt="alt text"><br><img src="/image-1.png" alt="alt text"><br>写入BurstLength和CASLatency，完全是硬件自动写入，代码没管<br><img src="/image-4.png" alt="alt text"></p><h2 id="突发读时序"><a href="#突发读时序" class="headerlink" title="突发读时序"></a>突发读时序</h2><p><img src="/image-2.png" alt="alt text"><br>16位写入，原始实例化了1个dsramhelper。burstLength设置成为了，这里就突发的读入了两个16bit。因为无论是lb、lh、lw都是读入32bit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤 2：测试16位写入和读取</span></span><br><span class="line">read_memory_16bit((<span class="type">uint16_t</span> *)start, size);</span><br></pre></td></tr></table></figure><p><img src="/image-5.png" alt="alt text"></p><h2 id="突发写时序"><a href="#突发写时序" class="headerlink" title="突发写时序"></a>突发写时序</h2><p>尤其注意传col的时候也是传bank的。所以sdram支持4个bank的开放，active时基于其中一个bank，read&#x2F;write时选择一个bank。取巧的做法是锁存row地址而不是锁存row中的数据，等到read&#x2F;write时使用bank索引锁存的row，bank，col一起访存<br><img src="/image-3.png" alt="alt text"><br>16位写入，原始实例化了1个dsramhelper。burstLength很早就设置成1了，为的是32写入时可以突发，虽然后面的col写入需要放弃，但col该加还得加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤 2：测试16位写入和读取</span></span><br><span class="line">write_memory_16bit((<span class="type">uint16_t</span> *)start, size);</span><br></pre></td></tr></table></figure><p><img src="/image-8.png" alt="alt text"><br>32位写入，突发的写入两个16bit<br><img src="/image-7.png" alt="alt text"></p><h2 id="row-hit"><a href="#row-hit" class="headerlink" title="row hit"></a>row hit</h2><p>acitve的时候激活,如果rowhit了就不用active了，但是目前没实现row的寄存器（4bank*512col），所以只好禁止row hit了<br>以下图是因为row hit了所以没有active状态传入row和way和bank，就读错了<br><img src="/image-17.png" alt="alt text"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open row hit</span></span><br><span class="line"><span class="keyword">if</span> (row_open_q[addr_bank_w] &amp;&amp; addr_row_w == active_row_q[addr_bank_w])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!ram_rd_w)</span><br><span class="line">        next_state_r = STATE_WRITE0;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next_state_r = STATE_READ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// Row miss, close row, open new row</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (row_open_q[addr_bank_w])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    next_state_r   = STATE_PRECHARGE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ram_rd_w)</span><br><span class="line">        target_state_r = STATE_WRITE0;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        target_state_r = STATE_READ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// No open row, open row</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    next_state_r   = STATE_ACTIVATE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ram_rd_w)</span><br><span class="line">        target_state_r = STATE_WRITE0;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        target_state_r = STATE_READ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><p>还需要修改sdram控制器，最不想做的事情<br><img src="/image-9.png" alt="alt text"><br>col在一次传输中都是32bit对齐的，是0，2，4这样的数，因为在sdram的视角下，即使对col_1写16bit也是对col_0写32bit。只不过在第二次传输是将strb和wen置为有效</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Address bits</span></span><br><span class="line"><span class="keyword">wire</span> [SDRAM_ROW_W-<span class="number">1</span>:<span class="number">0</span>] addr_col_w = (SDRAM_2BYTE_NUM == <span class="number">1</span>) ?</span><br><span class="line">  &#123;&#123;(SDRAM_ROW_W-SDRAM_COL_W)&#123;<span class="number">1&#x27;b0</span>&#125;&#125;, ram_addr_w[SDRAM_COL_W:<span class="number">2</span>], <span class="number">1&#x27;b0</span>&#125; :</span><br><span class="line">  &#123;&#123;(SDRAM_ROW_W-SDRAM_COL_W)&#123;<span class="number">1&#x27;b0</span>&#125;&#125;, <span class="number">1&#x27;b0</span>,ram_addr_w[SDRAM_COL_W:<span class="number">2</span>]&#125;;</span><br></pre></td></tr></table></figure><p><img src="/image-14.png" alt="alt text"><br><img src="/image-13.png" alt="alt text"></p><p>位扩展后32位读取不需要突发了，因此不用到state_write1，但state_write0仍需要检测突发以应对64位或更高位的突发访问。此时要精确控制ack_q-&gt;ram_ack_i(axi_core)-&gt; ram_ack_i(axi_pmem) -&gt; push_i(u_response) 的拍数。多一拍的话会多压入一个data，当axi_bvalid&#x2F;axi_rvalid-&gt;resp_accept_w-&gt;pop_i(u_response)时会弹出提前压入栈的数据。</p><p><img src="/image-16.png" alt="alt text"></p><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2><p>先来算一下一共能代表多少字节。</p><p>原先2**25 &#x3D; 32MB</p><table><thead><tr><th><strong>地址空间位数</strong></th><th><strong>地址位数</strong></th><th><strong>way</strong></th><th><strong>row</strong></th><th><strong>bank</strong></th><th><strong>col</strong></th><th><strong>字节偏移</strong></th></tr></thead><tbody><tr><td>25</td><td>24</td><td>-</td><td>13</td><td>2</td><td>9</td><td>1</td></tr></tbody></table><p>在最不常用的地方扩展，在地址最前面加上一bit的way，2**27 &#x3D; 128MB</p><table><thead><tr><th><strong>地址空间位数</strong></th><th><strong>地址位数</strong></th><th><strong>way</strong></th><th><strong>row</strong></th><th><strong>bank</strong></th><th><strong>col</strong></th><th><strong>字节偏移</strong></th></tr></thead><tbody><tr><td>27</td><td>25</td><td>1</td><td>13</td><td>2</td><td>9</td><td>2</td></tr></tbody></table><p>但是ysyxsoc分配给sdram了2**29 &#x3D; 512MB空间</p><h1 id="chisel"><a href="#chisel" class="headerlink" title="chisel"></a>chisel</h1><h2 id="vec"><a href="#vec" class="headerlink" title="vec"></a>vec</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sdram = <span class="type">VecInit</span>(<span class="type">Seq</span>(sdram0.io, sdram1.io))</span><br></pre></td></tr></table></figure><p>Exception in thread “main” java.lang.IllegalArgumentException: requirement failed: can’t create Vec with heterogeneous types class ysyx.SDRAMHelper0$$anon$3 and class ysyx.SDRAMHelper1$$anon$4</p><p>问题出在使用 VecInit 创建 Vec 时，传入的 Seq 包含了不同类型的元素：sdram0.io 和 sdram1.io，分别是 SDRAMHelper0 和 SDRAMHelper1 的 IO 类型。即使这两个IO内部元素相同也不算同一个类型。<br>解决方法：<br>统一使用SDRAMHelperIO</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">SDRAMHelperIO</span>)</span><br></pre></td></tr></table></figure><p>(实例化的模板都是SDRAMHelper，verilator找不到SDRAMHelper_${instanceId})</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDRAMHelper</span>(<span class="params">instanceId: <span class="type">Int</span></span>)</span></span><br><span class="line">  setInline(<span class="string">s&quot;SDRAMHelper_<span class="subst">$&#123;instanceId&#125;</span>.v&quot;</span>,</span><br><span class="line">    <span class="string">s&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">       |module SDRAMHelper_$&#123;instanceId&#125;(</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdata = <span class="type">Reg</span>(<span class="type">Vec</span>(<span class="type">SDRAMNum</span>,<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>)))</span><br><span class="line">dqout := rdata.asTypeOf(dqout)</span><br></pre></td></tr></table></figure><p>Exception in thread “main” chisel3.package$ChiselException: Connection between sink (sdramChisel.dqout: Wire[UInt&lt;32&gt;]) and source (sdramChisel.rdata: Reg[UInt&lt;16&gt;[2]]) failed @: Sink (UInt&lt;32&gt;) and Source (UInt&lt;16&gt;[2]) have different types.</p><p>asTypeOf 并不能直接将 Vec[UInt] 转换为 UInt，因为它们在结构上不兼容。如果需要将整个 Vec 转换为一个宽度为 32 位的 UInt，可以使用 asUInt。相反，UInt转换成vec就可以asTypeOf。<br>解决方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdata = <span class="type">Reg</span>(<span class="type">Vec</span>(<span class="type">SDRAMNum</span>,<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>)))</span><br><span class="line">dqout := rdata.asUInt</span><br><span class="line"><span class="keyword">val</span> wdata = <span class="type">Reg</span>(<span class="type">Vec</span>(<span class="type">SDRAMNum</span>,<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>)))</span><br><span class="line">wdata := dqin.asTypeOf(wdata)</span><br><span class="line"><span class="keyword">val</span> mask = <span class="type">Reg</span>(<span class="type">Vec</span>(<span class="type">SDRAMNum</span>,<span class="type">UInt</span>(<span class="number">2.</span><span class="type">W</span>)))</span><br><span class="line">mask := (~io.dqm).asTypeOf(mask)</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> until <span class="type">SDRAMNum</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  sdram.foreach &#123; sdram =&gt;</span><br><span class="line">    sdram.row := <span class="number">0.</span><span class="type">U</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logic"><a href="#logic" class="headerlink" title="logic"></a>logic</h2><p>看似command是wire，但是却综合出了Reg</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> command =</span><br><span class="line">  <span class="type">MuxCase</span>(<span class="type">COMMAND_INHIBIT</span>, <span class="type">Seq</span>(</span><br><span class="line">    (!io.cs &amp;&amp; io.ras &amp;&amp; io.cas &amp;&amp; io.we) -&gt; <span class="type">NOP</span>,</span><br></pre></td></tr></table></figure><p><img src="/image-10.png" alt="alt text"><br><img src="/image-6.png" alt="alt text"><br>automatic：<br>在 SystemVerilog 中，automatic 表示这个变量是 自动变量，即每次进入 always 块时重新创建，而不是在模块级别共享。<br>logic 是 SystemVerilog 中的新数据类型，类似于 Verilog 中的 reg<br>跨时钟域的always中，就会有这样的在新时钟域赋值的wire</p><h1 id="运算优先级大于移位"><a href="#运算优先级大于移位" class="headerlink" title="运算优先级大于移位"></a>运算优先级大于移位</h1><p><img src="/image-11.png" alt="alt text"><br>要使用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1.</span><span class="type">U</span> &lt;&lt; <span class="type">BurstLength</span>).asUInt <span class="number">-1.</span><span class="type">U</span> </span><br></pre></td></tr></table></figure><p>make ARCH&#x3D;riscv32e-ysyxsoc run ALL&#x3D;printf | tee sdram</p><p>make ARCH&#x3D;riscv32e-ysyxsoc run ALL&#x3D;printf | tee &gt;(grep “sdram” &gt;&gt; sdram)</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>sdram在最高地址开辟栈时，写入sp报错，因为做了字和位扩展会增大4被sdram空间<br><img src="/image-18.png" alt="alt text"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;SDRAM控制器的实现与优化，包括配置切换、时序控制、突发传输等功能的详细说明。&lt;/p&gt;</summary>
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="存储器" scheme="http://example.com/categories/ysyx/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="硬件设计" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="存储控制器" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    
    <category term="SDRAM" scheme="http://example.com/tags/SDRAM/"/>
    
  </entry>
  
  <entry>
    <title>NEMU-NPC-YSYXSoC性能对比</title>
    <link href="http://example.com/2023/11/27/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/nemu-npc-ysyxsoc/"/>
    <id>http://example.com/2023/11/27/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/nemu-npc-ysyxsoc/</id>
    <published>2023-11-26T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="切换清单"><a href="#切换清单" class="headerlink" title="切换清单"></a>切换清单</h1><p>1.npc-chisel&#x2F;nemu中make menuconfig切换SoC和nemu的运行target<br>2.npc-chisel 修改代码里的ysyxSoC &#x3D; true&#x2F;false</p><p>#切换用几个sdram<br>1.ysyxsoc&#x2F;perip&#x2F;sdram<br>2.ysyxsoc&#x2F;src&#x2F;device&#x2F;SDRAM.scala</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;切换清单&quot;&gt;&lt;a href=&quot;#切换清单&quot; class=&quot;headerlink&quot; title=&quot;切换清单&quot;&gt;&lt;/a&gt;切换清单&lt;/h1&gt;&lt;p&gt;1.npc-chisel&amp;#x2F;nemu中make menuconfig切换SoC和nemu的运行target&lt;br&gt;2</summary>
      
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="性能优化" scheme="http://example.com/categories/ysyx/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="CPU设计" scheme="http://example.com/tags/CPU%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="性能测试" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="仿真器" scheme="http://example.com/tags/%E4%BB%BF%E7%9C%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>PSRAM控制器实现</title>
    <link href="http://example.com/2023/11/17/ysyx/ysyxsoc/psram/"/>
    <id>http://example.com/2023/11/17/ysyx/ysyxsoc/psram/</id>
    <published>2023-11-16T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>PSRAM控制器的实现与二级加载机制的详细说明。</p><span id="more"></span><h2 id="二级加载"><a href="#二级加载" class="headerlink" title="二级加载"></a>二级加载</h2><table><thead><tr><th>存储器</th><th>flash</th><th>sram</th><th>psram</th></tr></thead><tbody><tr><td>起始地址</td><td>0x30000000</td><td>0x0f000000</td><td>0x80000000</td></tr><tr><td>运行的程序</td><td>fsbl</td><td>bootloader</td><td>trm_init</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;PSRAM控制器的实现与二级加载机制的详细说明。&lt;/p&gt;</summary>
    
    
    
    <category term="ysyx" scheme="http://example.com/categories/ysyx/"/>
    
    <category term="存储器" scheme="http://example.com/categories/ysyx/%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
    
    <category term="一生一芯" scheme="http://example.com/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="硬件设计" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="PSRAM" scheme="http://example.com/tags/PSRAM/"/>
    
    <category term="存储控制器" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>人工智能课程笔记</title>
    <link href="http://example.com/2023/05/09/course/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    <id>http://example.com/2023/05/09/course/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</id>
    <published>2023-05-08T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>为应付期末人工智能论文，记录一下有用的网站，以防忘记</p><span id="more"></span><h2 id="1-大模型网站"><a href="#1-大模型网站" class="headerlink" title="1.大模型网站"></a>1.大模型网站</h2><h4 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT"></a>ChatGPT</h4><p><a href="https://chat.openai.com/">https://chat.openai.com/</a><br><a href="https://openai.com/">https://openai.com/</a></p><h4 id="文心一言"><a href="#文心一言" class="headerlink" title="文心一言"></a>文心一言</h4><p><a href="https://yiyan.baidu.com/">https://yiyan.baidu.com/</a><br>飞桨AI(调用文心一言)<br><a href="https://aistudio.baidu.com/cooperate/erniebotsdk">https://aistudio.baidu.com/cooperate/erniebotsdk</a></p><h4 id="智谱AI"><a href="#智谱AI" class="headerlink" title="智谱AI"></a>智谱AI</h4><p><a href="https://open.bigmodel.cn/">https://open.bigmodel.cn/</a></p><h4 id="星火大模型"><a href="#星火大模型" class="headerlink" title="星火大模型"></a>星火大模型</h4><p><a href="https://xinghuo.xfyun.cn/">https://xinghuo.xfyun.cn/</a></p><h2 id="2-调用API-python"><a href="#2-调用API-python" class="headerlink" title="2.调用API(python)"></a>2.调用API(python)</h2><h4 id="用飞桨AI调用文心大模型"><a href="#用飞桨AI调用文心大模型" class="headerlink" title="用飞桨AI调用文心大模型"></a>用飞桨AI调用文心大模型</h4><p><a href="https://zhuanlan.zhihu.com/p/661241466">https://zhuanlan.zhihu.com/p/661241466</a></p><h4 id="智谱AI官方调用文档"><a href="#智谱AI官方调用文档" class="headerlink" title="智谱AI官方调用文档"></a>智谱AI官方调用文档</h4><p><a href="https://open.bigmodel.cn/dev/api#chatglm_turbo">https://open.bigmodel.cn/dev/api#chatglm_turbo</a></p><h4 id="星火大模型-1"><a href="#星火大模型-1" class="headerlink" title="星火大模型"></a>星火大模型</h4><p><a href="https://zhuanlan.zhihu.com/p/671067886">https://zhuanlan.zhihu.com/p/671067886</a></p><h2 id="3-prompt"><a href="#3-prompt" class="headerlink" title="3.prompt"></a>3.prompt</h2><h4 id="大模型时代的科研基础之：Prompt-Engineering"><a href="#大模型时代的科研基础之：Prompt-Engineering" class="headerlink" title="大模型时代的科研基础之：Prompt Engineering"></a>大模型时代的科研基础之：Prompt Engineering</h4><iframe src="//player.bilibili.com/player.html?aid=313877142&bvid=BV13P41197c6&cid=1137176592&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>可以当作研究过程写进论文<h2 id="4-评估模型好坏的方法"><a href="#4-评估模型好坏的方法" class="headerlink" title="4.评估模型好坏的方法"></a>4.评估模型好坏的方法</h2><h4 id="干货分享！如何评估-大型语言模型（LLMs）的输出质量？评估方法大盘点！"><a href="#干货分享！如何评估-大型语言模型（LLMs）的输出质量？评估方法大盘点！" class="headerlink" title="干货分享！如何评估 大型语言模型（LLMs）的输出质量？评估方法大盘点！"></a>干货分享！如何评估 大型语言模型（LLMs）的输出质量？评估方法大盘点！</h4><p><a href="https://zhuanlan.zhihu.com/p/660777460">https://zhuanlan.zhihu.com/p/660777460</a></p><h4 id="【Mo-人工智能技术博客】联邦学习鲁棒性及相关论文分享"><a href="#【Mo-人工智能技术博客】联邦学习鲁棒性及相关论文分享" class="headerlink" title="【Mo 人工智能技术博客】联邦学习鲁棒性及相关论文分享"></a>【Mo 人工智能技术博客】联邦学习鲁棒性及相关论文分享</h4><p><a href="https://zhuanlan.zhihu.com/p/337048283">https://zhuanlan.zhihu.com/p/337048283</a></p><h4 id="《大模型时代的科研》之2-Prompt-Engineering-提示词工程"><a href="#《大模型时代的科研》之2-Prompt-Engineering-提示词工程" class="headerlink" title="《大模型时代的科研》之2: Prompt Engineering (提示词工程)"></a>《大模型时代的科研》之2: Prompt Engineering (提示词工程)</h4><p>这个是在讲怎么构造好的prompt,与本次论文关系不大<br><a href="https://zhuanlan.zhihu.com/p/631922240">https://zhuanlan.zhihu.com/p/631922240</a></p><h4 id="大模型鲁棒不鲁棒，PromptBench测一测-首个大语言模型提示鲁棒性的评测基准PromptBench"><a href="#大模型鲁棒不鲁棒，PromptBench测一测-首个大语言模型提示鲁棒性的评测基准PromptBench" class="headerlink" title="大模型鲁棒不鲁棒，PromptBench测一测: 首个大语言模型提示鲁棒性的评测基准PromptBench"></a>大模型鲁棒不鲁棒，PromptBench测一测: 首个大语言模型提示鲁棒性的评测基准PromptBench</h4><p><a href="https://zhuanlan.zhihu.com/p/637219127">https://zhuanlan.zhihu.com/p/637219127</a></p><h2 id="5-debug"><a href="#5-debug" class="headerlink" title="5.debug"></a>5.debug</h2><h4 id="python文件名不能与包名重复"><a href="#python文件名不能与包名重复" class="headerlink" title="python文件名不能与包名重复"></a>python文件名不能与包名重复</h4><p><a href="https://blog.csdn.net/long_songs/article/details/129070598">https://blog.csdn.net/long_songs/article/details/129070598</a></p><h4 id="windows中为终端设置代理"><a href="#windows中为终端设置代理" class="headerlink" title="windows中为终端设置代理"></a>windows中为终端设置代理</h4><p><a href="https://blog.csdn.net/qq_43651168/article/details/131074308">https://blog.csdn.net/qq_43651168/article/details/131074308</a></p><h4 id="python同步遍历两个列表"><a href="#python同步遍历两个列表" class="headerlink" title="python同步遍历两个列表"></a>python同步遍历两个列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for prompt, reference in zip(test_accuarcy_cases, test_accuarcy_reference):</span><br><span class="line">#balbala</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="6-短信接收代理"><a href="#6-短信接收代理" class="headerlink" title="6.短信接收代理"></a>6.短信接收代理</h2><p><a href="https://sms-activate.org/">https://sms-activate.org/</a></p><h2 id="f1score"><a href="#f1score" class="headerlink" title="f1score"></a>f1score</h2><p><a href="https://www.flyai.com/article/683">https://www.flyai.com/article/683</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为应付期末人工智能论文，记录一下有用的网站，以防忘记&lt;/p&gt;</summary>
    
    
    
    <category term="course" scheme="http://example.com/categories/course/"/>
    
    <category term="AI" scheme="http://example.com/categories/course/AI/"/>
    
    
    <category term="人工智能" scheme="http://example.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="课程笔记" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git版本控制使用指南</title>
    <link href="http://example.com/2023/05/07/tools/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/05/07/tools/git%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-06T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git版本控制系统的使用指南，包括基本操作、分支管理、团队协作等内容。</p><span id="more"></span><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>在 Git 中，你可以使用以下命令来查看和修改配置：<br>查看配置</p><pre><code>查看全局配置：</code></pre><p>bash<br>git config –global –list</p><pre><code>查看当前仓库的配置：</code></pre><p>bash<br>git config –local –list</p><pre><code>查看系统配置：</code></pre><p>bash<br>git config –system –list</p><p>如果你只想知道某个特定配置的值，你可以这样做：</p><p>bash<br>git config &lt;配置项名称&gt;</p><p>例如，要查看全局的用户名配置：</p><p>bash<br>git config –global user.name</p><p>修改配置</p><pre><code>设置全局配置：    设置用户名：bash`git config --global user.name &quot;Your Name&quot;`    设置邮箱：bash`git config --global user.email &quot;your.email@example.com&quot;`设置当前仓库的配置：</code></pre><p>与全局配置类似，但使用 –local 代替 –global。<br>3. 设置系统配置：</p><p>通常不推荐修改系统配置，除非你有特定的理由。<br>4. 直接编辑配置文件：</p><p>你也可以直接编辑 Git 的配置文件。这些文件通常位于以下位置：</p><ul><li><strong>全局配置</strong>：<code>~/.gitconfig</code>  </li><li><strong>系统配置</strong>：<code>/etc/gitconfig</code>（Linux）或 <code>/usr/local/git/etc/gitconfig</code>（macOS）  </li><li><strong>当前仓库配置</strong>：仓库目录下的 <code>.git/config</code> 文件。使用文本编辑器打开这些文件，然后进行相应的修改。</li></ul><p>注意：当你设置或修改配置时，Git 会尝试从多个级别（系统、全局、本地）获取配置值。如果某个配置项在多个级别都有设置，Git 会优先使用本地仓库的配置，然后是全局配置，最后是系统配置。</p><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p><code>git remote</code>命令在Git中用于管理一组跟踪的远程仓库。它允许您查看、添加、修改和删除与您的本地仓库关联的远程仓库的配置。远程仓库通常是位于互联网或其他网络中的仓库，可以是一个中心仓库，也可以是另一个开发者的仓库，您可以从中拉取（pull）数据或向其推送（push）数据。使用<code>git remote</code>可以进行以下操作：</p><ul><li><p><strong>查看远程仓库</strong>：使用<code>git remote</code>或<code>git remote -v</code>命令可以列出所有已配置的远程仓库。<code>-v</code>（verbose，详细）选项会额外显示每个远程仓库的URL。</p></li><li><p><strong>添加远程仓库</strong>：使用<code>git remote add &lt;name&gt; &lt;url&gt;</code>命令可以添加新的远程仓库，其中<code>&lt;name&gt;</code>是您为远程仓库指定的简短名称（如<code>origin</code>），<code>&lt;url&gt;</code>是远程仓库的URL。</p></li><li><p><strong>更改远程仓库URL</strong>：使用<code>git remote set-url &lt;name&gt; &lt;newurl&gt;</code>命令可以更改已存在的远程仓库的URL。</p></li><li><p><strong>删除远程仓库</strong>：使用<code>git remote remove &lt;name&gt;</code>或<code>git remote rm &lt;name&gt;</code>命令可以删除一个远程仓库的引用。</p></li><li><p><strong>重命名远程仓库</strong>：使用<code>git remote rename &lt;oldname&gt; &lt;newname&gt;</code>命令可以重命名远程仓库的简称。</p></li></ul><p>在协同工作流中，<code>git remote</code>命令是非常重要的，它使得开发者能够与远程仓库交互，共享代码和协作。例如，<code>origin</code>通常是克隆仓库时自动创建的默认远程仓库名称，代表了克隆来源的仓库。通过管理远程仓库，您可以轻松地同步本地更改到远程服务器，或者拉取他人的更改到您的本地仓库中。</p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>luluji@luluji-virtual-machine:~&#x2F;nuttxspace$ git clone <a href="https://github.com/apache/nuttx.git">https://github.com/apache/nuttx.git</a> nuttx<br>正克隆到 ‘nuttx’…<br>fatal: 无法访问 ‘<a href="https://github.com/apache/nuttx.git/'%EF%BC%9Agnutls_handshake()">https://github.com/apache/nuttx.git/&#39;：gnutls_handshake()</a> failed: Error in the pull function.</p><p>通过安装这些库解决了：<br>sudo apt -y install build-essential nghttp2 libnghttp2-dev libssl-dev</p><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>git push之前先git pull<br>git checkout master之前先git add和commit</p><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>正在克隆子模块时就是在克隆，不会有进度条，跟卡住了似的是正常的</p><p>riscv-gnu-toolchain中的子模块可换源<br><a href="https://www.bilibili.com/read/cv28486387/">https://www.bilibili.com/read/cv28486387/</a></p><p>当更改了.gitmodules文件中的子模块 URL 时，Git 不会自动更新已经克隆的子模块。如果希望使用新的 URL 克隆子模块，则需要手动更新子模块的配置。</p><p>要更新子模块的配置，可以运行以下命令：<br>git submodule sync</p><p>这个命令将会更新本地存储库中的 .git&#x2F;config 文件以反映.gitmodules文件中的新 URL。<br>然后，可以运行以下命令来更新子模块：<br>git submodule update –init –recursive</p><p>这个命令将会使用.gitmodules文件中的新 URL 克隆或更新子模块，并递归地更新任何子模块的子模块（如果有的话）。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>git add .的撤回<br>git reset</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>* 和 *.*：忽略所有文件。<br>!<em>&#x2F;：不忽略所有目录。<br>!Makefile：不忽略 Makefile 文件。<br>!</em>.mk：不忽略所有 .mk 文件。<br>!<em>.scala：不忽略所有 .scala 文件。<br>!</em>.[cSh]：不忽略所有 .c、.S 和 .h 文件。<br>!<em>.v：不忽略所有 .v 文件。<br>!</em>.cpp：不忽略所有 .cpp 文件。<br>!*.cc：不忽略所有 .cc 文件。<br>!.gitignore：不忽略 .gitignore 文件。<br>!.scalafmt.conf：不忽略 .scalafmt.conf 文件。<br>!build.sc：不忽略 build.sc 文件。<br>!README.md：不忽略 README.md 文件。<br>!&#x2F;src&#x2F;**：不忽略 src 目录及其所有子目录和文件。<br>!&#x2F;patch&#x2F;**：不忽略 patch 目录及其所有子目录和文件。<br>!&#x2F;perip&#x2F;**：不忽略 perip 目录及其所有子目录和文件。<br>!&#x2F;spec&#x2F;**：不忽略 spec 目录及其所有子目录和文件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Git版本控制系统的使用指南，包括基本操作、分支管理、团队协作等内容。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    <category term="版本控制" scheme="http://example.com/categories/tools/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
    <category term="版本控制" scheme="http://example.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    <category term="开发工具" scheme="http://example.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="团队协作" scheme="http://example.com/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理课程笔记</title>
    <link href="http://example.com/2023/04/21/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/04/21/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2023-04-20T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本课程笔记涵盖了计算机组成原理的核心概念，包括CPU设计、存储系统、指令系统等内容，以及相关的实践经验。</p><span id="more"></span><p><a href="https://blog.csdn.net/qq_62325622/article/details/134804522?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-134804522-blog-124206736.235%5Ev43%5Epc_blog_bottom_relevance_base9&spm=1001.2101.3001.4242.1&utm_relevant_index=3">https://blog.csdn.net/qq_62325622/article/details/134804522?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-134804522-blog-124206736.235^v43^pc_blog_bottom_relevance_base9&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本课程笔记涵盖了计算机组成原理的核心概念，包括CPU设计、存储系统、指令系统等内容，以及相关的实践经验。&lt;/p&gt;</summary>
    
    
    
    <category term="course" scheme="http://example.com/categories/course/"/>
    
    <category term="体系结构" scheme="http://example.com/categories/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="CPU设计" scheme="http://example.com/tags/CPU%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="课程笔记" scheme="http://example.com/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    <category term="数字电路" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>x86架构学习笔记</title>
    <link href="http://example.com/2023/04/16/os/x86%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/04/16/os/x86%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-04-15T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>x86架构相关的学习笔记，包括寄存器使用、分段机制、特权级别等重要概念的详细说明。</p><span id="more"></span><h2 id="ebp和-esp"><a href="#ebp和-esp" class="headerlink" title="%ebp和%esp"></a>%ebp和%esp</h2><p><a href="https://blog.csdn.net/qq_41683305/article/details/104249224">https://blog.csdn.net/qq_41683305/article/details/104249224</a></p><h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p><a href="https://blog.csdn.net/cc_net/article/details/24726287">https://blog.csdn.net/cc_net/article/details/24726287</a></p><h2 id="RPL-CPL-DPL"><a href="#RPL-CPL-DPL" class="headerlink" title="RPL CPL DPL"></a>RPL CPL DPL</h2><p><a href="https://blog.csdn.net/qq_37414405/article/details/84535145">https://blog.csdn.net/qq_37414405/article/details/84535145</a></p><h2 id="xv6启动"><a href="#xv6启动" class="headerlink" title="xv6启动"></a>xv6启动</h2><p><a href="https://zhuanlan.zhihu.com/p/164684999">https://zhuanlan.zhihu.com/p/164684999</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;x86架构相关的学习笔记，包括寄存器使用、分段机制、特权级别等重要概念的详细说明。&lt;/p&gt;</summary>
    
    
    
    <category term="os" scheme="http://example.com/categories/os/"/>
    
    <category term="体系结构" scheme="http://example.com/categories/os/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="x86" scheme="http://example.com/tags/x86/"/>
    
    <category term="CPU架构" scheme="http://example.com/tags/CPU%E6%9E%B6%E6%9E%84/"/>
    
    <category term="汇编语言" scheme="http://example.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统内存检测机制</title>
    <link href="http://example.com/2023/04/16/os/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B/"/>
    <id>http://example.com/2023/04/16/os/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B/</id>
    <published>2023-04-15T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍操作系统中的内存检测机制，包括NuttX系统的内存管理和KFENCE内存错误检测工具的使用方法。</p><span id="more"></span><h2 id="nuttx"><a href="#nuttx" class="headerlink" title="nuttx"></a>nuttx</h2><p><a href="https://nuttx.apache.org/docs/latest/">https://nuttx.apache.org/docs/latest/</a></p><h2 id="kfence"><a href="#kfence" class="headerlink" title="kfence"></a>kfence</h2><p><a href="https://www.cnblogs.com/sky-heaven/p/16527927.html">https://www.cnblogs.com/sky-heaven/p/16527927.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍操作系统中的内存检测机制，包括NuttX系统的内存管理和KFENCE内存错误检测工具的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="os" scheme="http://example.com/categories/os/"/>
    
    <category term="内存管理" scheme="http://example.com/categories/os/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="系统编程" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存管理" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Buildroot使用指南</title>
    <link href="http://example.com/2023/04/09/tools/buildroot%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/04/09/tools/buildroot%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-08T16:00:00.000Z</published>
    <updated>2024-01-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Buildroot工具的使用指南，包括系统构建、交叉编译、定制化配置等内容。</p><span id="more"></span><p>在使用Buildroot构建嵌入式Linux系统时，<code>BR2_EXTERNAL</code>是一个重要的机制，它允许用户将自定义的配置、包（packages）、板级支持包（board support packages，简称BSPs）、以及其他构建脚本和文件集成到Buildroot构建过程中，而不必直接修改Buildroot的主树。这种机制非常有用，因为它使得维护自定义修改和跟踪Buildroot官方更新变得更加容易。</p><h3 id="使用BR2-EXTERNAL的优势"><a href="#使用BR2-EXTERNAL的优势" class="headerlink" title="使用BR2_EXTERNAL的优势"></a>使用BR2_EXTERNAL的优势</h3><ul><li><strong>模块化</strong>：允许将自定义内容和Buildroot主树分开，便于管理。</li><li><strong>易于维护</strong>：更新Buildroot版本时，可以避免合并冲突，简化维护工作。</li><li><strong>重用性</strong>：相同的自定义配置和包可以轻松地在多个项目之间共享和重用。</li></ul><h3 id="如何使用BR2-EXTERNAL"><a href="#如何使用BR2-EXTERNAL" class="headerlink" title="如何使用BR2_EXTERNAL"></a>如何使用BR2_EXTERNAL</h3><ol><li><p><strong>创建外部树结构</strong>：首先，你需要创建一个目录作为你的外部树，这个目录将包含你的自定义配置和文件。外部树的推荐目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">your-external-tree/</span><br><span class="line">├── Config.in</span><br><span class="line">├── external.desc</span><br><span class="line">├── external.mk</span><br><span class="line">├── configs/</span><br><span class="line">├── board/</span><br><span class="line">├── package/</span><br><span class="line">└── fs/</span><br></pre></td></tr></table></figure><p>其中<code>configs/</code>用于存放自定义的配置文件，<code>package/</code>用于存放自定义的软件包描述文件，<code>board/</code>可能包含板级特定文件，如启动脚本和覆盖层。</p></li><li><p><strong>设置BR2_EXTERNAL环境变量</strong>：在运行Buildroot的<code>make menuconfig</code>之前，通过环境变量<code>BR2_EXTERNAL</code>指向你的外部树目录。这可以通过在命令行中直接设置，或者添加到你的shell配置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export BR2_EXTERNAL=/path/to/your-external-tree</span><br></pre></td></tr></table></figure><p>或者，在make命令中直接指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make BR2_EXTERNAL=/path/to/your-external-tree menuconfig</span><br></pre></td></tr></table></figure></li><li><p><strong>使用自定义配置和包</strong>：一旦设置了<code>BR2_EXTERNAL</code>，Buildroot构建系统将自动识别外部树中的配置和包。你可以在<code>make menuconfig</code>中选择这些包，或者使用外部树中定义的配置作为构建的起点。</p></li><li><p><strong>构建系统</strong>：使用你的配置构建系统。如果一切设置正确，Buildroot将包含你的外部树中的自定义内容进行构建。</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>多个外部树</strong>：从Buildroot 2016.11版本开始，<code>BR2_EXTERNAL</code>支持指定多个外部树路径，使用冒号(<code>:</code>)分隔。</li><li><strong>版本兼容性</strong>：在使用<code>BR2_EXTERNAL</code>时，要确保外部树中的自定义内容与Buildroot的版本兼容。</li></ul><p>通过使用<code>BR2_EXTERNAL</code>，你可以灵活地扩展Buildroot，添加自定义功能和支持，同时保持与Buildroot主树的清晰分离，这对于项目的长期维护和升级非常有益。</p><p>当使用<code>BR2_EXTERNAL</code>机制在Buildroot中引入外部树时，你需要在外部树的根目录创建一些特定的文件和目录来定义你的自定义配置、板级支持包、软件包和文件系统扩展。以下是如何组织和编写这些文件的一些基本指导：</p><h3 id="1-Config-in"><a href="#1-Config-in" class="headerlink" title="1. Config.in"></a>1. Config.in</h3><p><code>Config.in</code>是一个Kconfig文件，它定义了在Buildroot配置界面中出现的选项。这个文件通常用来引入外部软件包的配置选项或者特定的配置界面。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;My Custom Options&quot;</span></span><br><span class="line"></span><br><span class="line">config BR2_PACKAGE_MY_CUSTOM_PACKAGE</span><br><span class="line">    bool <span class="string">&quot;My custom package&quot;</span></span><br><span class="line">    help</span><br><span class="line">      This option will enable my custom package.</span><br><span class="line"></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure><p>此文件中定义的选项可以在Buildroot的配置界面中找到，并允许用户启用或禁用特定功能。</p><h3 id="2-external-desc"><a href="#2-external-desc" class="headerlink" title="2. external.desc"></a>2. external.desc</h3><p><code>external.desc</code>是Buildroot 2020.02版本后引入的新文件，用于描述外部树的元数据，如名称和描述。这个文件不是必需的，但有助于识别外部树。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: my-external-tree</span><br><span class="line">description: My custom external tree for Buildroot</span><br></pre></td></tr></table></figure><h3 id="3-external-mk"><a href="#3-external-mk" class="headerlink" title="3. external.mk"></a>3. external.mk</h3><p><code>external.mk</code>是Makefile片段，用于包含外部软件包的构建规则。这个文件会被Buildroot构建系统自动包含。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of including a custom package</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(BR2_PACKAGE_MY_CUSTOM_PACKAGE)</span>,y)</span><br><span class="line"><span class="keyword">include</span> package/my_custom_package/my_custom_package.mk</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="4-configs"><a href="#4-configs" class="headerlink" title="4. configs&#x2F;"></a>4. configs&#x2F;</h3><p><code>configs/</code>目录包含预定义的Buildroot配置文件，这些文件可以通过<code>make &lt;config_name&gt;_defconfig</code>命令使用。这些配置文件通常用于快速配置Buildroot以使用特定的板级支持包或软件包组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Example of a custom defconfig file</span><br><span class="line">BR2_PACKAGE_MY_CUSTOM_PACKAGE=y</span><br></pre></td></tr></table></figure><h3 id="5-board"><a href="#5-board" class="headerlink" title="5. board&#x2F;"></a>5. board&#x2F;</h3><p><code>board/</code>目录包含特定于板级的文件，如启动脚本、内核配置片段或根文件系统覆盖层。</p><h3 id="6-package"><a href="#6-package" class="headerlink" title="6. package&#x2F;"></a>6. package&#x2F;</h3><p><code>package/</code>目录包含自定义软件包的描述和构建规则。每个软件包目录下通常包含两个文件：<code>Config.in</code>和<code>&lt;package_name&gt;.mk</code>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># package/my_custom_package/Config.in</span></span><br><span class="line">config BR2_PACKAGE_MY_CUSTOM_PACKAGE</span><br><span class="line">    bool <span class="string">&quot;My custom package&quot;</span></span><br><span class="line">    help</span><br><span class="line">      My custom package description.</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># package/my_custom_package/my_custom_package.mk</span></span><br><span class="line">MY_CUSTOM_PACKAGE_VERSION = 1.0</span><br><span class="line">MY_CUSTOM_PACKAGE_SITE = <span class="variable">$(TOPDIR)</span>/path/to/my_custom_package/source</span><br><span class="line">MY_CUSTOM_PACKAGE_LICENSE = GPL-2.0+</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> MY_CUSTOM_PACKAGE_BUILD_CMDS</span><br><span class="line">    <span class="variable">$(MAKE)</span> CC=<span class="string">&quot;<span class="variable">$(TARGET_CC)</span>&quot;</span> -C $(@D)</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> MY_CUSTOM_PACKAGE_INSTALL_TARGET_CMDS</span><br><span class="line">    <span class="variable">$(INSTALL)</span> -D -m 0755 $(@D)/my_custom_package <span class="variable">$(TARGET_DIR)</span>/usr/bin</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">eval</span> $(generic-package)</span>)</span><br></pre></td></tr></table></figure><h3 id="7-fs"><a href="#7-fs" class="headerlink" title="7. fs&#x2F;"></a>7. fs&#x2F;</h3><p><code>fs/</code>目录用于添加自定义文件系统支持。这里可以放置生成特定类型文件系统镜像的脚本和配置。</p><p>这些文件和目录为你提供了一个框架来扩展Buildroot，添加自定义板级支持、软件包和配置。确保遵循Buildroot的文档和现有的样板（boilerplate）代码来正确实现这些自定义扩展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Buildroot工具的使用指南，包括系统构建、交叉编译、定制化配置等内容。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/tools/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="Buildroot" scheme="http://example.com/tags/Buildroot/"/>
    
    <category term="嵌入式系统" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="交叉编译" scheme="http://example.com/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
    <category term="Linux开发" scheme="http://example.com/tags/Linux%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
